# Сервис-календарь
## Первая часть из ТЗ на сервис "Календарь"
Сделать "заготовку" для микросервиса-календаря.

Определить структуру определяющую событие, написать методы для добавления/изменения/удаления событий.

Хранить события в памяти, без персистентности. 

#

## Вторая часть из ТЗ на сервис "Календарь"
### GRPC сервис
Создать GRPC спецификацию для сервиса-календаря.

Сгенерировать GRPC сервер и клиент, проверить работу сервиса.

Отделить модель данных от Protobuf структур. 

#

## Третья часть из ТЗ на сервис "Календарь"
### Использование баз данных.
Изменить код сервиса-календаря, так что бы события сохранялись в базе данных.

Использовать sqlx для более удобной обработки запросов.

Слой работы с базой данных нужно вынести в отдельный пакет.

#

## Четвертая часть из ТЗ на сервис "Календарь" 
### Работа с очередями
Реализовать "напоминания" о событиях с помощью RabbitMQ.

Создать процесс, который периодически сканирует основную базу данных, выбирая события о которых нужно напомнить.

Создать процесс, который читает сообщения из очереди и шлет уведомления. 

#

#

## Общее описание

Сервис "Календарь" представляет собой максимально упрощенный сервис для хранения календарных событий и оправки уведомлений.
Сервис предполагает:
* возможность добавить/обновить событие
* возможность получить список событий на день/неделю/месяц
* возможность получить уведомление за N дней до события
Сервис НЕ предполагает:
* авторизации
* разграничения доступа
* web интерфейса

## Архитектура

Полностью завершенный сервис состоит из 5 процессов:

### API
API - предоставляет GRPC интерфейс для пользователей, реализует основные методы сервиса.
Т.к. авторизация и разделение доступа выходят за рамки сервиса, мы предполагаем что ID пользователя
просто передается через параметры или метаданные GRPC запроса.
Также API предоставляет prometheus интерфейс для мониторинга сервиса.

### Планировщик
Планировщик - фоновый процесс, не взаимодействует с пользователем, выполняет периодические задания:
* Выбор событий, требующих уведомления и отправка уведомлений в очередь рассыльщику
* Очистка старых (более 1 года назад) событий

### Рассыльщик
Рассыльщик - фоновый процесс, занимается отправкой уведомлений.
В рамках задания нет необходимости реальной отправки сообщений, достаточно если рассыльщик просто будет записывать их в лог.

### СУБД
Реляционная СУБД (postgres) - хранит информацию о событиях

## Очередь сообщений
Очередь сообщений (RabbitMQ) - используется для передачи событий рассыльщику


## Описание сущностей

### Событие
Событие - основная сущность, содержит в себе поля:
* UUID - уникальный идентификатор события
* Заголовок - короткий текст
* Дата и время события
* Длительность события
* Описание события - длинный текст, опционально
* Пользователь, владелец события
* За сколько времени высылать уведомление, опционально

### Уведомление
Уведомление - временная сущность, складывается в очередь для рассыльщика, содержит поля:
* Заголовок события
* Дата события
* Пользователь, которому отправлять

## Описание методов
* Создать (событие)
* Обновить (ID события, событие)
* Удалить (ID события)
* Список Событий На День (дата)
* Список Событий На Неделю (дата начала недели)
* Список Событий Не Месяц (дата начала месяца)

## Конфигурация, логирование, контейнеризация

Рекомендуется собирать проект в виде одного бинарного файла, а для запуска 
конкретного микросервиса использовать аргументы командной строки:

    ./cal_service api
    ./cal_service scheduler
    ./cal_service sender

Проект следует оформить в виде набора контейнеров для каждого из микросервисов.
Поскольку запуск будет осуществлять в контейнерах - логи нужно печатать в STDERR.
Сервисы должны получать настройки (например адрес и логин в СУБД) черезе переменные окружения.
При желании можно использовать конфиг viper, с поддержкой переменных окружения.

Развертывание микросервиса должно осуществляться командой `docker-compose up` в директории с проектом.

## Тестирование

Для проекта необходимо реализовать интеграционные тесты, т.е. тесты проверяющие работу на уровне API.
Интеграционные тесты так же можно создать с помощью пакета `testing` и запускать в отдельном контейнере
в том же compose окружении что и остальные микросервися. В таком случае тесты смогут получать адрес работающего
сервиса через переменные окружения и выполнять запросы к нему и проверять состояние базы данных.

## Этапы разработки

Разработку лучше разделить на три этапа:
* API + СУБД
* Добавляем Планировщик, Рассыльщик, Очередь сообщений
* Создаем Docker образы, docker-compose, пишем интеграционный тест
Тогда на каждом этапе можно будет получить осмысленный проект


